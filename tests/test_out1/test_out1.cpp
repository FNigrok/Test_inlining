// Experiments for project.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//
//Здесь будут содержаться эксперименты для проверки гипотез.
#include <iostream>
#include <ctime>
#include <vector>

void test_out1(int a) {
    std::cout << a << std::endl;
}

inline void test_out1_in(int a) {
    std::cout << a << std::endl;
}

int main()
{
    float in = 0;
    std::vector<float> times;
    for (int i = 0; i < 10; i++) {
        unsigned int start = clock();
        for (int j = 0; j < 100000; j++) {
            //test_out1(j);
            //test_out1_in(j);
        }
        unsigned int end = clock();
        in += (end - start) / 1000.0;
        times.push_back(in);
        //std::cout << times[i] << "here" << std::endl;
        in = 0;
    }
    for (int i = 0; i < times.size(); i++) {
        std::cout << times[i] << std::endl;
    }
    //std::cout << "No inlining time: " << no_in / 1000.0 << "s" << std::endl;
    //std::cout << "With inlining time: " << in / 1000.0  << "s";

}
//test_out1 показал что нельзя сказать что есть различие между присутствием и отсутствием inline
//Первая проверка на 10000+ вызовах функции(строчка 20) происходит заметно дольше всех остальных (можно рассматривать как выброс)
//Остальные находятся примерно в одном промежутке (что значит что можем относится как к нормальному распределению)
//Не ожидается что от увеличения кол-ва тестов нулевая гипотеза отвергается(проверить в след раз)
//Интересное наблюдение: Функция заметно ускоряется при второй проверке (строчка 20) и имеет примерно одинаковую скорость для всех последующих (проверено)
//Скорее всего это и есть встроенная оптимизация компилятора, которая возможно является проверяемой оптимизацией (object inlining)
//Придумать как проверить является ли это другим типом оптимизации
//Перевести тест в хеддер, и сделать проверку на функцию с return (также в след раз)

